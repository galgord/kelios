# Architecture & Standards: "ConfConnect"

| **Document Version** | 1.0 |
| :--- | :--- |
| **Philosophy** | Pragmatic Clean Architecture |
| **Commit Style** | Conventional & Atomic |

---

## 1. Clean Architecture Implementation

We adapt Clean Architecture to leverage the strengths of NestJS and React without over-engineering.

### 1.1 Backend (NestJS)
We separate concerns into three distinct layers. Data flows **down**, Dependencies point **inward** (conceptually).

1.  **Interface Layer (Controllers / Resolvers)**
    * *Responsibility:* Handle HTTP requests, parse DTOs, and return responses.
    * *Rule:* **NO Business Logic.** Only validation and calling Services.
    * *Example:* `EventsController` receives a POST request, validates `CreateEventDto`, and calls `EventsService`.

2.  **Application Layer (Services)**
    * *Responsibility:* The brain. Contains all business rules, calculations, and orchestrations.
    * *Rule:* Agnostic of HTTP. Should not know about `req` or `res` objects.
    * *Example:* `EventsService` checks if the user is an organizer, calculates fees, and asks the Repository to save.

3.  **Infrastructure Layer (Prisma / Adapters)**
    * *Responsibility:* Talk to the outside world (Database, Stripe, Supabase).
    * *Rule:* The only place where SQL/ORM or 3rd party SDKs are touched.
    * *Example:* `PrismaService`, `StripeService`.

### 1.2 Frontend (React)
We use a **Feature-Based** architecture that separates UI from Logic.

1.  **Presentation Layer (UI Components)**
    * *Location:* `src/components/ui` (Shared) or `src/features/**/components`.
    * *Responsibility:* Render pixels.
    * *Rule:* Pure functions. They receive data via props. No API calls inside.

2.  **Container/Logical Layer (Hooks & Pages)**
    * *Location:* `src/features/**/hooks` or Page components.
    * *Responsibility:* Manage state, handle events, and fetch data.
    * *Rule:* Connects the UI to the API.

3.  **Data Layer (API & Query)**
    * *Location:* `src/lib/api-client.ts` and `useQuery` hooks.
    * *Responsibility:* Server communication.
    * *Rule:* All caching and synchronization logic lives here (TanStack Query).

---

## 2. Git Strategy: Atomic Commits

We follow **Atomic Commits**. This means every commit must be a single, complete, and revertible unit of work.

### 2.1 The Rules
1.  **One Logical Change:** Do not bundle a bug fix, a new feature, and a formatting change into one commit.
2.  **Passes Tests:** Never commit broken code. The app must build.
3.  **Descriptive Messages:** Use the **Conventional Commits** standard.

### 2.2 Conventional Commits Format
Structure: `<type>(<scope>): <subject>`

* **feat:** A new feature (e.g., `feat(auth): add magic link login`).
* **fix:** A bug fix (e.g., `fix(stripe): correct webhook signature verification`).
* **chore:** Maintenance, config, dependencies (e.g., `chore(deps): upgrade tailwind`).
* **refactor:** Code change that neither fixes a bug nor adds a feature (e.g., `refactor(events): extract event card to component`).
* **docs:** Documentation only (e.g., `docs: update readme`).
* **style:** Formatting, missing semi-colons, etc.

### 2.3 Why Atomic?
* **Easier Reverts:** If a feature breaks production, you can revert just that `feat` commit without undoing the `fix` you made 5 minutes later.
* **Better Code Review:** Reviewing 5 small commits is infinitely easier than reviewing 1 massive "WIP" commit.

---

## 3. Best Practices

### 3.1 Backend (NestJS)
* **DTOs are Mandatory:** Every input (Body, Query, Param) must have a defined DTO class with `class-validator` decorators.
    * *Why:* Guarantees type safety and prevents bad data from entering the Service layer.
* **Env Config:** Never hardcode secrets. Use `@nestjs/config` and validate `.env` variables on startup using Joi or Zod.
* **Return Objects, Not Entities:** Don't return the raw Prisma User entity (which might contain the password hash). Return a `UserResponseDto`.

### 3.2 Frontend (React)
* **Mobile-First CSS:** Write styles for mobile first, then add `md:` or `lg:` breakpoints.
    * *Correct:* `className="w-full md:w-1/2"`
    * *Incorrect:* `className="w-1/2 max-md:w-full"`
* **Composition over Inheritance:** Don't build massive "God Components" with 20 props. Build small components that accept `children`.
* **Custom Hooks:** If a component has more than 2 `useEffect` or complex state logic, extract it to a custom hook (e.g., `useEventForm`).

### 3.3 Database (Prisma)
* **No Logic in SQL:** Avoid complex Stored Procedures. Keep logic in the Application Layer (NestJS) for easier debugging and version control.
* **Migrations:** Always review the SQL generated by `prisma migrate dev` before applying.

---

## 4. Testing Strategy (The "Simple Win" Approach)

Since we are moving fast, we prioritize **High Value** tests.

1.  **E2E Tests (Playwright):** *Highest Priority.*
    * Test the "Critical Paths" (Login, Create Event, Buy Ticket).
    * If these pass, the app works.
2.  **Unit Tests (Jest):** *Medium Priority.*
    * Test complex business logic (e.g., fee calculation).
    * Skip testing simple CRUD services or UI components.